CONTEXTES ET OBJECTIFS :

Le projet du module de test logiciel a pour objectif de vous faire manipuler l’ensemble des notions et
outils vus en cours et en TP au cours du semestre. En particulier, le projet met en jeu le test unitaire
(fonctionnel et structurel), le test d’intégration, l’injection de dépendances et les doublures de test, la
couverture de code et l’analyse par mutation. Pour chacune de ces notions, vous pouvez vous référer
aux supports de cours et vous inspirer des TPs disponibles sur Moodle.
Assurez-vous de lire ce document attentivement avant de commencer le projet. Comme de coutume,
ce document donne une spécification précise de certains des aspects de l’application et sous-spécifie
d’autres parties. Lorsque nécessaire, faites des choix que vous refléterez dans vos scénarios de test. Les
modalités de remise et d’évaluation sont précisées à la fin de ce document.


1- DESCRIPTION GENERALE DE L'APPLICATION :

On souhaite développer une application permettant à ses utilisateurs de planifier un séjour d’une certaine
durée à une destination donnée incluant transports, hôtels et activités à proximité. L’utilisateur spécifie ses
préférences concernant le transport, l’hébergement, et les activités, et l’application retourne un ou plusieurs
forfaits incluant chacun de ces éléments et correspondant à ses préférences. Les informations factices manipu-
lées par l’application (transports, hôtels, préférences, etc.) sont stockées soit dans une base de données locale,
soit dans un ensemble de fichiers aux formats JSON ou CSV dont vous déterminerez la forme et le contenu.
Il n’est pas nécessaire d’implémenter une interface graphique avancée pour interagir avec l’application déve-
loppée.

1.1 Données métiers :

— Un trajet s’effectue d’une ville de départ à une ville d’arrivée, à une date et une heure données (de départ
et d’arrivée), via un mode de transport spécifique (avion ou train), à un certain prix ;
— Un hôtel se situe à une adresse donnée, dans une ville donnée, et possède une note comprise entre une
et cinq étoiles ainsi qu’un certain prix par nuit ;
— Une activité a lieu à une adresse et une date données, est d’une certaine catégorie (e.g., exposition, sport,
musique, etc.) et peut avoir un prix ;
— Un forfait comprend une solution de transport (aller et retour, chacun direct ou indirect), un hôtel à des-
tination sur la durée prévue, ainsi qu’un ensemble d’activités effectuables à proximité. Le cas échéant,
le forfait détaille les erreurs rencontrées lors de sa création (e.g., critères insatisfiables, erreur de récu-
pération des données, indisponibilité des services externes, etc.).

1.2 Critères utilisateurs :

Un utilisateur peut choisir parmi un ensemble de critères qui s’appliquent lors de la recherche d’un séjour.
Tous les critères choisis par l’utilisateur s’appliquent strictement et l’application ne doit pas retourner un
forfait qui ne les satisferait pas. Il n’est pas nécessaire d’implémenter un algorithme d’optimisation multi-
critères qui chercherait une solution optimale : si plusieurs solutions sont possibles, alors tous les forfaits
correspondants sont retournés à l’utilisateur. Un utilisateur peut saisir les critères suivants :
— Forfait : un utilisateur spécifie sa ville de départ et de retour, une durée de séjour à partir d’une date
donnée, et un prix maximal à ne pas dépasser pour le forfait complet ;
— Transport : train ou avion (ou sans préférence) ; l’utilisateur peut choisir de prioriser le prix le moins
cher ou la durée la plus courte si plusieurs solutions de transport existent ;
— Hôtel : note minimum (ou sans préférence) ; l’utilisateur peut choisir de prioriser le prix le moins cher
ou le nombre d’étoiles maximum si plusieurs hôtels correspondent ;
— Activités : l’utilisateur spécifie une ou plusieurs catégories d’activités qui peuvent être incluses dans le
forfait (sport, musique, etc.) ainsi qu’une distance maximale (ou sans préférence) entre son hôtel et le
lieu de l’activité.

1.3 Architecture :

L’application comporte plusieurs services permettant de récupérer les données de transport, d’héberge-
ment, les activités, et les préférences utilisateurs. Il n’est pas nécessaire de récupérer des informations réelles
depuis des services en ligne : vous simulerez ces données, stockées soit dans une base de données locale soit
dans de simples fichiers JSON ou CSV.
Afin de vous assurez que les activités proposées respectent le critère de distance maximale défini par
l’utilisateur entre son hôtel et l’activité, vous utiliserez le service de geocoding geocode.maps manipulé au
TP4 pour convertir les adresses postales en coordonnées GPS. Ensuite, vous pourrez vous appuyer sur la
formule d’Haversine 1 pour estimer la distance (à vol d’oiseau) entre ces coordonnées.
Afin de paralléliser le travail des membres du groupe et de faciliter l’écriture de tests dès le début du projet,
il est recommandé de concevoir l’application de manière modulaire en vous accordant d’abord sur les inter-
faces des composants principaux de l’application. Il est ainsi judicieux de définir des interfaces et classes aux
responsabilités limitées (par exemple, une interface permettant d’obtenir les transports correspondants à des
critères donnés, une interface permettant d’obtenir les hôtels correspondants à des critères donnés, une inter-
face assemblant ces services pour produire un ou plusieurs forfaits conformes aux attentes de l’utilisateur, une
interface permettant de mesurer la distance entre deux addresses, etc.). La spécification et l’implémentation
de ces différentes interfaces peut être répartie entre les membres du groupe et permet l’écriture de premiers
tests unitaires sur la base de ces interfaces sans attendre leur implémentation finale.



2 POLITIQUE DE TEST :

2.1 Exigences :

L’application doit respecter certaines exigences, que vous vous emploierez à vérifier dans vos tests. Cette
liste n’est pas exhaustive, et vous la compléterez en testant les comportement normaux et anormaux de l’appli-
cation en vous basant sur les techniques de test vues en cours. Veillez à nommer vos tests de manière explicite
pour décrire le scénario qu’ils exercent.
— Pour les besoins de ce projet, on considère que tous les transports, hôtels et activités sont toujours
disponibles à la réservation ;
— Un voyage (aller ou retour) peut s’effectuer en une seule ou plusieurs étapes (auquel cas, les villes-étapes
doivent être cohérentes). Par exemple, un voyage de Bordeaux à Rennes peut comporter un premier
trajet de Bordeaux à Paris puis un second de Paris à Rennes. Dans ce cas, l’application doit allouer un
temps de correspondance raisonnable que vous définirez et testerez ;
— Les trajets composant un voyage (aller ou retour) doivent utiliser un mode de transport homogène
(seulement en train ou seulement en avion), mais les modes de transport peuvent différer entre l’aller
et le retour si cela est conforme aux préférences de l’utilisateur ;
— En cas d’égalité entre plusieurs options selon le critère choisi par l’utilisateur, l’autre critère est utilisé
pour discriminer. Par exemple, si deux voyages sont au même prix (respectivement, de la même durée),
alors le voyage le plus court (respectivement, le moins cher) est choisi ;
— Un utilisateur ne peut assister à deux activités différentes à la même date ;
— L’application vise toujours à maximiser le nombre d’activités effectuées dès lors que le prix maximal du
forfait complet le permet ;
— Si des erreurs sont rencontrées lors de l’établissement d’un forfait (services externes indisponibles,
critères insatisfiables, etc.), alors le forfait est tout de même retourné en l’état et détaille les erreurs
rencontrées.

2.2 Tests unitaires :

L’application interagit avec un service distant pour effectuer la conversion d’adresses postales en adresses
GPS. Elle interagit également avec le système de fichier et/ou une base de données pour consulter les données
de transports, les hôtels et les activités. Il est donc primordial d’isoler l’interaction avec ces services lors du
test unitaire pour éviter que les tests ne soient trop fragiles et/ou coûteux. Vous vous emploierez donc à implé-
menter l’application de sorte à favoriser le découplage entre ces services et leurs consommateurs en favorisant
une conception modulaire et l’injection de dépendances. Du point de vue des tests, vous vous appuierez sur
l’injection de dépendances pour substituer ces services par des doublures de test (stubs et/ou mocks) dès que
nécessaire. En particulier, ces doublures vous permettront de tester plus efficacement les comportement nor-
maux et anormaux comme vu au TP4.

2.3 Tests d’intégration :

Une fois vos tests unitaires implémentés, vous écrirez des tests d’intégration pour l’application. Ces tests
d’intégration vérifieront que l’application fonctionne correctement lorsque les différents services collaborent
ensemble. Contrairement aux test unitaires, ils n’utilisent donc pas de doublures de test pour isoler les services
les uns des autres, mais vérifient que la composition des services réels produit le comportement attendu lors
de l’exécution de scénarios complets mettant en jeu plusieurs composants.
Pour rappel, les tests d’intégration sont détectés automatiquement par Maven grâce au suffixe “IT”. Une
classe de test nommée MyServiceTest sera exécutée en tant que test unitaire par la commande mvn test et
une classe de test nommée MyServiceTestIT sera exécutée en tant que test d’intégration par la commande
mvn integration-test.

2.4 Rapports de couverture et de mutation :

Lorsque vous aurez obtenu une première version de vos tests (notamment en implémentant les exigences
et par analyse fonctionnelle : partitions, classes d’équivalence et valeurs limites), vous devrez vous assurer de
la qualité de votre suite de test.
Pour ce faire, vous vous appuierez sur les métriques de couverture de code (en utilisant l’outil JaCoCo)
et l’analyse par mutation (en utilisant l’outil PIT). En partant de votre suite de test initiale, générez d’abord
un rapport de couverture de code avec JaCoCo et analysez la couverture des instructions et des branches.
Implémentez ensuite de nouveaux tests pour couvrir les parties non couvertes par votre suite de test initiale.
Reportez-vous au TP3 pour la manipulation de l’outil JaCoCo.
Une fois satisfaits de la couverture de votre suite de test, utilisez l’outil PIT pour conduire l’analyse par
mutation de votre suite de test. Augmentez votre suite de test avec de nouveaux tests permettant d’améliorer
le score de mutation obtenu en tuant les mutants survivants. Reportez-vous au TP5 pour la manipulation de
l’outil PIT.


MODALITES D’EVALUATION :

— Le projet est à réaliser par groupes de trois ou quatre personnes ;
— Vous rédigerez un court rapport (∼ 4–8 pages) au format PDF qui détaillera les points suivants :
1. Noms et prénoms des membres de l’équipe ;
2. Présentation générale de l’architecture de l’application développée (interfaces/classes/services
et leurs interactions) et des choix de conception effectués. Vous pourrez par exemple vous ap-
puyer sur un diagramme de classes et/ou sur un diagramme de séquence présentant le chemin
d’exécution nominal ;
3. Manuel d’utilisation, dont : commandes à lancer pour la compilation du projet, l’exécution
des tests unitaires, l’exécution des tests d’intégration, la production du rapport de couverture,
la production du rapport de mutation, et l’exécution de l’application sur un jeu de données
prédéfini ;
4. Rapport de couverture : présentation des scores de couverture (aux niveaux instruction et
branche) et du rapport de couverture (par exemple à l’aide d’une copie d’écran montrant le
score global obtenu pour chaque classe). Pour les parties non couvertes par votre suite de test
(le cas échéant), vous donnerez une brève justification : un cas de test permettant de couvrir
cette partie n’est pas pertinent du point de vue des exigences, le code non couvert est trivial
(e.g., DTO, accesseurs), etc. ;
5. Rapport de mutation : présentation du score de mutation obtenu et justification (le cas échéant)
des mutants non tués par les tests (survivants) : mutants équivalents, écrire un test tuant ce
mutant n’est pas pertinent du point de vue des exigences, manque de temps, etc. ;
6. Si vous le souhaitez, vous pourrez inclure une section détaillant les difficultés rencontrées lors
du projet ainsi que votre évaluation personnelle de la pertinence et de la charge de ce projet.
— Vous inclurez ce rapport au sein d’une archive .zip ou .tar.gz contenant également :
1. Le code source de l’application développée ;
2. Les tests unitaires et d’intégration développés pour l’application ;
3. Les rapports de couverture et de mutation pré-générés au format HTML.
— Les critères pris en compte pour l’évaluation sont les suivants :
1. Clarté et intelligibilité des tests unitaires et d’intégration : nommage, descriptions et com-
mentaires éventuels, respect de la convention AAA (Arrange, Act, Assert), adéquation avec
les exigences, utilisation appropriée des fixtures, choix des assertions, cas nominaux et cas
d’erreur, etc. ;
2. Utilisation judicieuse de l’injection de dépendances et des doublures de test : veillez à concevoir
votre application de manière modulaire de sorte à pouvoir mocker les interactions lorsque
nécessaire lors du test unitaire ;
3. Qualité du court rapport PDF et en particulier de la justification des scores de couverture et
de mutation. Un score de couverture ou de mutation moindre mais bien justifié est préférable
à un score de couverture ou de mutation plus élevé mais sans justification ;
4. Plutôt que les fonctionnalités de l’application, c’est la qualité des tests et des rapports associés
qui est évaluée. Vous apporterez donc un soin tout particulier à la qualité de votre code et de
vos tests.