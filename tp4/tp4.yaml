TP4 : Injection de dépendances et doublures de test
Le framework Mockito
— Mockito a est un framework permettant l’implémentation et la manipulation de bouchons (stubs) et
d’objets factices (mocks) très populaire dans l’écosystème Java/JUnit ;
— Sa documentation de référence est disponible à l’adresse https://javadoc.io/doc/org.mockito/
mockito-core/latest/org/mockito/Mockito.html
— Mockito s’appuie abondamment sur des méthodes statiques et du chaînage de méthodes pour pro-
poser une API dite fluide. b La plupart de ces méthodes peuvent être importées dans vos tests
comme suit : import static org.mockito.Mockito.*. Référez-vous à la documentation associée
pour identifier les méthodes à votre disposition et leur rôle.
— Lors de l’écriture d’un stub pour une méthode qui peut éventuellement lancer une exception
(par exemple when(mock).mayThrowException().thenReturn(value)), le compilateur vous force
à prendre en compte l’exception qui peut être levée. Dans le contexte de vos tests, vous pouvez
simplement la laisser se propager en adossant throws AnException à la signature de la méthode de
test et elle sera traitée par le framework de test.
a. https://site.mockito.org/
b. https://www.martinfowler.com/bliki/FluentInterface.html
1 L’application TempGuardian
On souhaite développer une application météorologique permettant à ses utilisateurs de configurer un
nombre arbitraire d’adresses postales (par exemple “1 Avenue du Dr Albert Schweitzer, 33400 Talence”) et de
recevoir des alertes lorsque les conditions météorologiques à ces adresses (température, vent, pluie) atteignent
des seuils qu’ils auront définis. Une alerte doit être émise dès lors que les seuils sont franchis. Si plusieurs seuils
sont franchis à un même instant (par exemple température minimale et pluie maximale), alors autant d’alertes
que nécessaire sont émises.
Pour chaque utilisateur, on connait les données suivantes :
— Un nombre arbitraire d’adresses postales et, indépendamment pour chacune d’entre elles :
— Une option pour désactiver les alertes à cette adresse ;
— Un ensemble de données météorologiques à surveiller parmi : la température, le vent, et la pluvio-
métrie. Pour chacune de ces données :
— Un seuil minimal (respectivement maximal) en deçà (respectivement au-delà) duquel une
alerte doit être émise, pour chacune de ces données. Pour la température, les seuils sont expri-
més en degrés Celsius (par exemple en-dessous de -1°C) ; pour le vent en km/h (par exemple
au-dessus de 15km/h) ; pour la pluie en millimètres sur la dernière heure écoulée (par exemple
au-dessus de 5mm). Pour chaque donnée, les seuils peuvent être définis ou non.
— Une option pour désactiver toute alerte, pour toutes les adresses enregistrées.
Les paramètres de configuration pour chaque utilisateur (adresses, seuils, etc.) sont fournis en entrée de
l’application sous la forme d’un fichier dont vous déciderez librement du format (par exemple, CSV). Pour les
besoins du TP, les alertes ne sont pas directement envoyées à des utilisateurs imaginaires, mais sont simple-
ment écrites dans un autre fichier CSV stocké localement détaillant l’utilisateur contacté, la raison de l’alerte
(type de donnée, valeur relevée, seuil atteint), et l’heure d’émission de l’alerte. Le développement de cette
application ne requiert pas d’interface graphique quelconque ou de dialogue avec une base de données.
1 / 3
I3GL — Test Logiciel TP4 : Injection de dépendances et doublures de test
2 Interaction avec les services distants
Afin de récupérer les données nécessaires, l’application doit interagir avec des services distants.
Open-Meteo est un service de météorologie gratuit qui fournit ses données à travers une API REST. Par
exemple, l’appel suivant retourne la température en °C, la quantité de pluie tombée sur l’heure écoulée en mm,
et le vent en km/h aux coordonnées GPS de l’ENSEIRB-MATMECA (latitude 44.80662, longitude -0.60515) :
https://api.open-meteo.com/v1/forecast?latitude=44.80662&longitude=-0.60515&current=temperature_
2m,rain,wind_speed_10m. La classe TemperatureService contient un exemple d’interaction avec ce service.
Open-Meteo accepte en entrée des coordonnées GPS (latitude et longitude). Les utilisateurs étant associés
à des adresses postales, il vous faudra d’abord convertir celles-ci en coordonnées GPS. Le service de geocoding
geocode.maps vous permet d’effectuer cette conversion. Par exemple, l’appel suivant retourne les coordonnées
GPS de l’ENSEIRB-MATMECA : https://geocode.maps.co/search?q=ENSEIRB-MATMECA. Vous implémente-
rez donc également un service permettant d’effectuer la conversion des adresses postales en coordonnées GPS
en requêtant cette API. Il vous faudra pour cela récupérer une clé d’API : https://geocode.maps.co/join/.
L’implémentation des différents services, des consommateurs de ces services, et de leurs tests unitaires
peut être réalisée en parallèle au sein d’un groupe grâce aux injections de dépendances et aux doublures de
test. Accordez-vous d’abord sur les interfaces de ces services (méthodes, types de données attendus, etc.) de
sorte à pouvoir travailler de manière indépendante, puis implémentez-les et testez-les en parallèle. Veillez à ne
pas dépasser les 600 requêtes par minute, 5 000 par heure, et 10 000 par jour vers le service Open-Meteo. 1 Le
service de geocoding impose une limite d’une requête par seconde. Vous veillerez donc, dans l’implémentation
de ce service, à attendre au moins une seconde entre chaque requête.
3 Politique de test
3.1 Exigences
L’application doit respecter certaines exigences, que vous vous emploierez à vérifier dans vos tests. Cette
liste n’est pas exhaustive, et vous la compléterez en testant les comportement normaux et anormaux de l’appli-
cation en vous basant sur les techniques de test vues en cours. Veillez à nommer vos tests de manière explicite
pour décrire le scénario qu’ils exercent.
— Les alertes d’un utilisateur peuvent être activées ou désactivées, globalement ou pour une adresse en
particulier. L’application ne doit émettre des alertes que si celles-ci sont activées globalement et pour
l’adresse appropriée ;
— Si les informations retournées par le service météorologique sont au-delà des seuils configurés par
l’utilisateur (et que ses alertes sont activées) alors une alerte doit lui parvenir ;
— Inversement, aucune alerte ne doit être émise si les données météorologiques sont conformes aux seuils
définis, et ce même si les alertes sont activées ;
— Si un utilisateur a configuré plusieurs adresses différentes, ainsi que plusieurs seuils, on s’assurera que
les services de geocoding et de météorologie sont contactés le bon nombre de fois avec les données
adéquates ;
— De la même manière, si différents seuils d’alerte sont franchis, on s’assurera que le service d’émission
des alertes qui les stocke dans un fichier CSV est également contacté le bon nombre de fois, avec les
données appropriées ;
— Si un utilisateur a désactivé toutes ses alertes, alors il ne doit pas recevoir d’alerte même si elles sont
activées pour l’une de ses adresses enregistrées ;
— Les services distants contactés par l’application peuvent se comporter de manière normale ou anormale
(timeout, données retournées illisibles, etc.). Vous vous assurerez que l’application gère l’ensemble des
comportements normaux et anormaux de manière appropriée ;
— Il en va de même pour le service de notification aux utilisateurs qui peut, ou non, émettre l’alerte avec
succès.
1. https://open-meteo.com/en/terms
2 / 3
I3GL — Test Logiciel TP4 : Injection de dépendances et doublures de test
3.2 Tests unitaires
L’application interagit avec des services distants pour récupérer les informations météorologiques et ef-
fectuer la conversion depuis des adresses postales vers des coordonnées GPS. Elle interagit également avec le
système de fichier pour stocker les alertes émises. Il est donc primordial d’isoler l’interaction avec ces services
lors du test unitaire pour éviter que les tests soient trop fragiles (absence de connexion internet, limitations
du nombre d’appels sur une fenêtre donnée, évolution de l’API de ces services, erreur d’écriture sur disque,
etc.). Vous vous emploierez donc à implémenter l’application de sorte à favoriser le découplage entre ces ser-
vices (service météorologique, service de conversion d’adresse, service de stockage des alertes, etc.) et les
consommateurs de ces services en favorisant l’injection de dépendances. Du point de vue des tests, vous vous
appuierez sur l’injection de dépendances pour substituer ces services par des doublures de test (stubs et mocks)
dès que nécessaire. En particulier, ces doublures vous permettront de tester plus efficacement les comporte-
ment normaux et anormaux dans l’interaction avec les services externes. Reportez-vous à la documentation
de Mockito pour configurer correctement les attentes de vos doublures et vérifier que les interactions sont
correctes.
3.3 Tests d’intégration
Une fois vos tests unitaires implémentés, vous écrirez des tests d’intégration pour l’application. Ces tests
d’intégration vérifieront que l’application fonctionne correctement lorsque les différents services collaborent
ensemble. Contrairement aux test unitaires, ils n’utilisent donc pas de doublures de test pour isoler les services
les uns des autres, mais vérifient que la composition des services réels produit le comportement attendu. Ainsi,
l’exécution d’un test d’intégration mènera à des appels réels vers les services distants et à l’écriture d’alertes
dans le fichier CSV de sortie.
Pour rappel, les tests d’intégration sont détectés automatiquement par Maven grâce au suffixe "IT". Une
classe de test nommée MyServiceTest sera exécutée en tant que test unitaire par la commande mvn test et
une classe de test nommée MyServiceTestIT sera exécutée en tant que test d’intégration par la commande
mvn failsafe:integration-test.
3.4 Rapports de couverture
Lorsque vous aurez obtenu une première version de vos tests (notamment en implémentant les exigences
et par analyse fonctionnelle : partitions, classes d’équivalence et valeurs limites), vous devrez vous assurer de
la qualité de votre suite de test.
Pour ce faire, vous vous appuierez sur les métriques de couverture de code. En partant de votre suite de
test initiale, générez d’abord un rapport de couverture de code avec JaCoCo et analysez la couverture des
instructions et des branches. Implémentez ensuite de nouveaux tests pour couvrir les parties non couvertes
par votre suite de test initiale. Tout au long de l’implémentation de vos tests (unitaires et d’intégration),
appuyez-vous sur les rapports de couverture pour améliorer la qualité de vos tests.