\documentclass[11pt,a4paper]{article}

% ============================================
% PACKAGES
% ============================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage{fancyhdr}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{shapes.multipart, arrows.meta, positioning, fit, backgrounds, calc}

% ============================================
% CONFIGURATION
% ============================================
\geometry{margin=2.5cm}
\setlength{\headheight}{14pt}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=cyan,
    pdftitle={Rapport Projet Test Logiciel - Holitrip}
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{bash}{
    language=bash,
    backgroundcolor=\color{backcolour},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=none
}
\lstset{style=bash}

\pagestyle{fancy}
\fancyhf{}
\rhead{I3GL -- Test Logiciel 2025--2026}
\lhead{Projet Holitrip}
\rfoot{Page \thepage}

% ============================================
% DOCUMENT
% ============================================
\begin{document}

% ============================================
% PAGE DE TITRE
% ============================================
\begin{titlepage}
    \centering
    \vspace*{1cm}
    
    % Logo de l'école - remplacer par le chemin de votre logo
    \includegraphics[height=2.5cm]{logo_em.jpg}
    \vspace{0.5cm}
    
    {\scshape\Large I3GL -- Test Logiciel\par}
    \vspace{1.5cm}
    
    \rule{\linewidth}{0.5mm} \\[0.4cm]
    {\huge\bfseries Projet Holitrip\\[0.2cm]
    Application de Planification de Séjours\par}
    \rule{\linewidth}{0.5mm} \\[1.5cm]
    
    {\large
    Mohamed Dyae \textsc{Chellaf}\\[0.2cm]
    Mohamed Taha \textsc{Sandi}\\[0.2cm]
    Mohamed Reda \textsc{El Khader}\\[0.2cm]
    Mathieu \textsc{Morel}
    \par}
    
    \vfill
    {\large Département Informatique\\[0.2cm]
    2025/2026\par}
\end{titlepage}

\tableofcontents
\newpage

% ============================================
% SECTION 1 : ARCHITECTURE
% ============================================
\section{Architecture de l'application}

\subsection{Vue d'ensemble}

L'application \textbf{Holitrip} permet de planifier des séjours complets incluant transports (directs ou avec correspondances), hôtels et activités selon les préférences utilisateur. L'architecture repose sur le principe de \textbf{séparation des préoccupations} avec une distinction claire entre interfaces et implémentations, facilitant l'injection de dépendances et les tests unitaires avec doublures.

\subsection{Services et implémentations}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|l|p{6.5cm}|}
\hline
\textbf{Interface} & \textbf{Implémentation} & \textbf{Responsabilité} \\
\hline
\texttt{TransportService} & \texttt{JsonTransportService} & Recherche de transports avec algorithme BFS pour correspondances (max 3 legs, 60min min., homogénéité mode) \\
\hline
\texttt{HotelService} & \texttt{JsonHotelService} & Recherche d'hôtels par ville, note minimale et prix \\
\hline
\texttt{ActivityService} & \texttt{JsonActivityService} & Recherche d'activités avec filtrage par catégorie et distance depuis l'hôtel \\
\hline
\texttt{GeocodingService} & \texttt{ApiGeocodingService} & Conversion adresses → coordonnées GPS via API geocode.maps.co \\
\hline
\texttt{DistanceService} & \texttt{HaversineDistanceService} & Calcul de distance à vol d'oiseau (formule d'Haversine) \\
\hline
\texttt{PackageService} & \texttt{PackageBuilder} & Assemblage des forfaits complets selon critères utilisateur \\
\hline
\end{tabular}
\caption{Services de l'application}
\end{table}

\subsection{Modèles de données}

Les données métier sont dans le package \texttt{fr.univ.holitrip.model} :
\begin{itemize}[noitemsep]
    \item \texttt{Transport} : trajet unitaire (villes, dates, mode TRAIN/PLANE, prix)
    \item \texttt{Trip} : voyage complet (liste de transports pour gérer les correspondances)
    \item \texttt{Hotel} : hébergement (nom, adresse, note 1-5 étoiles, prix/nuit)
    \item \texttt{Activity} : activité (nom, adresse, date, catégorie, prix)
    \item \texttt{Package} : forfait complet (aller + retour + hôtel + activités + erreurs)
    \item \texttt{Coordinates} : coordonnées GPS (latitude, longitude)
\end{itemize}

\subsection{Diagramme de classes}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    interface/.style={
        rectangle split, rectangle split parts=2,
        draw=blue!70, fill=blue!5, thick,
        text width=3.8cm, align=center,
        font=\footnotesize
    },
    class/.style={
        rectangle split, rectangle split parts=3,
        draw=black!70, fill=gray!10, thick,
        text width=3.8cm, align=center,
        font=\footnotesize
    },
    model/.style={
        rectangle split, rectangle split parts=2,
        draw=green!50!black, fill=green!5, thick,
        text width=2.5cm, align=center,
        font=\scriptsize
    },
    implements/.style={-{Triangle[open]}, dashed, blue!60, thick},
    uses/.style={-{Stealth}, thick, red!70}
]

% === INTERFACES (top row) ===
\node[interface] (TransportService) at (0,0) {
    \textbf{<<interface>>}\\\textbf{TransportService}
    \nodepart{second}
    \texttt{findTransports()}
};

\node[interface] (HotelService) at (4.5,0) {
    \textbf{<<interface>>}\\\textbf{HotelService}
    \nodepart{second}
    \texttt{findHotels()}
};

\node[interface] (ActivityService) at (9,0) {
    \textbf{<<interface>>}\\\textbf{ActivityService}
    \nodepart{second}
    \texttt{findActivities()}
};

% === IMPLEMENTATIONS ===
\node[class] (JsonTransport) at (0,-3.5) {
    \textbf{JsonTransportService}
    \nodepart{second}
    \texttt{MAX\_LEGS = 3}\\
    \texttt{MIN\_CONN = 60min}
    \nodepart{third}
    \texttt{findMultiLegJourney()}\\
    \textit{(BFS algorithm)}
};

\node[class] (TransportHelper) at (0,-6.5) {
    \textbf{TransportHelper}
    \nodepart{second}
    \texttt{utility class}
    \nodepart{third}
    \texttt{isValidConnection()}\\
    \texttt{isSameMode()}\\
    \texttt{getTripDuration()}
};

\node[class] (JsonHotel) at (4.5,-3.5) {
    \textbf{JsonHotelService}
    \nodepart{second}
    \texttt{jsonFilePath}
    \nodepart{third}
    \texttt{findHotels()}\\
    \textit{(filter by rating)}
};

\node[class] (JsonActivity) at (9,-3.5) {
    \textbf{JsonActivityService}
    \nodepart{second}
    \texttt{geocodingService}\\
    \texttt{distanceService}
    \nodepart{third}
    \texttt{findActivities()}\\
    \textit{(filter by distance)}
};

% === Second row interfaces ===
\node[interface] (GeocodingService) at (0,-7) {
    \textbf{<<interface>>}\\\textbf{GeocodingService}
    \nodepart{second}
    \texttt{geocode(address)}
};

\node[interface] (DistanceService) at (4.5,-7) {
    \textbf{<<interface>>}\\\textbf{DistanceService}
    \nodepart{second}
    \texttt{calculateDistance()}
};

\node[interface] (PackageService) at (9,-7) {
    \textbf{<<interface>>}\\\textbf{PackageService}
    \nodepart{second}
    \texttt{findPackages()}
};

% === Second row implementations ===
\node[class] (ApiGeocoding) at (0,-10.5) {
    \textbf{ApiGeocodingService}
    \nodepart{second}
    \texttt{MAX\_RETRIES = 3}
    \nodepart{third}
    \texttt{geocode()}\\
    \textit{(geocode.maps.co)}
};

\node[class] (Haversine) at (4.5,-10.5) {
    \textbf{HaversineDistance}
    \nodepart{second}
    \texttt{EARTH\_R = 6371}
    \nodepart{third}
    \texttt{calculateDistance()}
};

\node[class] (PackageBuilder) at (9,-10.5) {
    \textbf{PackageBuilder}
    \nodepart{second}
    \texttt{all 5 services}\\
    \texttt{geocodeCache}
    \nodepart{third}
    \texttt{findPackages()}\\
    \texttt{selectBestTransport()}
};

% === MODELS (right side) ===
\node[model] (Transport) at (13.5,-1) {
    \textbf{Transport}
    \nodepart{second}
    \texttt{cities, mode}\\
    \texttt{dates, price}
};

\node[model] (Hotel) at (13.5,-3) {
    \textbf{Hotel}
    \nodepart{second}
    \texttt{name, city}\\
    \texttt{rating, price}
};

\node[model] (Activity) at (13.5,-5) {
    \textbf{Activity}
    \nodepart{second}
    \texttt{name, category}\\
    \texttt{date, price}
};

\node[model] (Package) at (13.5,-7) {
    \textbf{Package}
    \nodepart{second}
    \texttt{trips, hotel}\\
    \texttt{activities}
};

\node[model] (Coordinates) at (13.5,-9) {
    \textbf{Coordinates}
    \nodepart{second}
    \texttt{lat, lon}
};

% === ARROWS implements ===
\draw[implements] (JsonTransport.north) -- (TransportService.south);
\draw[implements] (JsonHotel.north) -- (HotelService.south);
\draw[implements] (JsonActivity.north) -- (ActivityService.south);
\draw[implements] (ApiGeocoding.north) -- (GeocodingService.south);
\draw[implements] (Haversine.north) -- (DistanceService.south);
\draw[implements] (PackageBuilder.north) -- (PackageService.south);

% === ARROW uses - JsonTransport uses TransportHelper ===
\draw[uses] (JsonTransport.south) -- (TransportHelper.north);

% === ARROWS uses - PackageBuilder (go down, left outside, then up) ===
\draw[uses] (PackageBuilder.south) -- ++(0,-0.5) -- ++(-11,0) -- ++(0,8) -- (JsonTransport.south);
\draw[uses] (PackageBuilder.south) -- ++(0,-0.7) -- ++(-6.5,0) -- ++(0,8.2) -- (JsonHotel.south);
\draw[uses] (PackageBuilder.south) -- ++(0,-0.9) -- ++(-2,0) -- ++(0,8.4) -- (JsonActivity.south);

% === ARROWS uses - JsonActivity to Geocoding/Distance ===
\draw[uses] (JsonActivity.south) -- ++(0,-0.4) -| (GeocodingService.north);
\draw[uses] (JsonActivity.south) -- ++(0,-0.4) -| (DistanceService.north);

% Background for models
\begin{scope}[on background layer]
    \node[draw=green!50!black, dashed, rounded corners, 
          fit=(Transport)(Hotel)(Activity)(Package)(Coordinates), 
          inner sep=8pt,
          label={[font=\footnotesize\bfseries]above:Mod\`eles}, 
          fill=green!3] {};
\end{scope}

% Legend
\node[font=\tiny, anchor=west] at (-2,-12.5) {
    \tikz[baseline=-0.5ex]{\draw[implements] (0,0) -- (0.6,0);} implements
    \quad
    \tikz[baseline=-0.5ex]{\draw[uses] (0,0) -- (0.6,0);} uses
};

\end{tikzpicture}
\caption{Diagramme de classes UML de l'application Holitrip}
\end{figure}

\subsection{Diagramme de séquence}

Le diagramme suivant illustre le flux d'exécution de la méthode \texttt{findPackages()} qui orchestre la recherche d'un forfait complet.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    actor/.style={rectangle, draw=black, fill=yellow!20, minimum width=1.6cm, minimum height=0.6cm, font=\scriptsize\bfseries},
    lifeline/.style={dashed, gray},
    message/.style={-{Stealth}, thick},
    return/.style={-{Stealth}, dashed}
]

% Actors (participants)
\node[actor] (Client) at (0, 0) {Client};
\node[actor] (PB) at (3, 0) {PackageBuilder};
\node[actor] (TS) at (6, 0) {TransportSvc};
\node[actor] (HS) at (9, 0) {HotelSvc};
\node[actor] (GS) at (12, 0) {GeocodingSvc};
\node[actor] (AS) at (15, 0) {ActivitySvc};

% Lifelines
\draw[lifeline] (Client.south) -- ++(0, -11);
\draw[lifeline] (PB.south) -- ++(0, -11);
\draw[lifeline] (TS.south) -- ++(0, -11);
\draw[lifeline] (HS.south) -- ++(0, -11);
\draw[lifeline] (GS.south) -- ++(0, -11);
\draw[lifeline] (AS.south) -- ++(0, -11);

% Activation bar for PackageBuilder
\fill[white, draw=black] (2.9, -0.8) rectangle (3.1, -10.2);

% Message 1: findPackages
\draw[message] (0, -1) -- node[above, font=\tiny] {1: findPackages(criteria)} (2.9, -1);

% Message 2: findTransports (outbound)
\draw[message] (3.1, -1.8) -- node[above, font=\tiny] {2: findTransports()} (6, -1.8);
\fill[white, draw=black] (5.9, -1.8) rectangle (6.1, -2.5);
\draw[return] (6, -2.4) -- node[above, font=\tiny] {transports} (3.1, -2.4);

% Message 3: findTransports (return trip)
\draw[message] (3.1, -3) -- node[above, font=\tiny] {3: findTransports(return)} (6, -3);
\fill[white, draw=black] (5.9, -3) rectangle (6.1, -3.6);
\draw[return] (6, -3.5) -- node[above, font=\tiny] {transports} (3.1, -3.5);

% Message 4: findHotels
\draw[message] (3.1, -4.2) -- node[above, font=\tiny] {4: findHotels()} (9, -4.2);
\fill[white, draw=black] (8.9, -4.2) rectangle (9.1, -4.8);
\draw[return] (9, -4.7) -- node[above, font=\tiny] {hotels} (3.1, -4.7);

% Message 5: geocode (hotel address)
\draw[message] (3.1, -5.4) -- node[above, font=\tiny] {5: geocode(hotel.address)} (12, -5.4);
\fill[white, draw=black] (11.9, -5.4) rectangle (12.1, -6);
\draw[return] (12, -5.9) -- node[above, font=\tiny] {Coordinates} (3.1, -5.9);

% Message 6: findActivities
\draw[message] (3.1, -6.6) -- node[above, font=\tiny] {6: findActivities(hotelCoords)} (15, -6.6);
\fill[white, draw=black] (14.9, -6.6) rectangle (15.1, -7.4);
\draw[return] (15, -7.3) -- node[above, font=\tiny] {activities} (3.1, -7.3);

% Self-call: filter and build
\draw[message] (3.1, -8) -- ++(0.6, 0) -- ++(0, -0.4) -- ++(-0.4, 0);
\node[font=\tiny, right] at (3.7, -8) {7: filterByBudget()};

\draw[message] (3.1, -8.8) -- ++(0.6, 0) -- ++(0, -0.4) -- ++(-0.4, 0);
\node[font=\tiny, right] at (3.7, -8.8) {8: assemblePackage()};

% Return to client
\draw[return] (2.9, -9.8) -- node[above, font=\tiny] {List<Package>} (0, -9.8);

% Notes
\node[rectangle, draw=orange!70, fill=orange!10, font=\tiny, rounded corners, align=left] at (7.5, -2.1) {BFS si\\pas direct};
\node[rectangle, draw=orange!70, fill=orange!10, font=\tiny, rounded corners, align=left] at (13.5, -5.7) {cache +\\retry x3};
\node[rectangle, draw=orange!70, fill=orange!10, font=\tiny, rounded corners, align=left] at (16.5, -7) {filtre\\distance};

\end{tikzpicture}
\caption{Diagramme de séquence de \texttt{findPackages()}}
\end{figure}

\subsection{Choix de conception}

\begin{enumerate}[noitemsep]
    \item \textbf{Injection de dépendances} : toutes les implémentations reçoivent leurs dépendances via constructeur, permettant de les remplacer par des mocks/stubs lors des tests.
    \item \textbf{Algorithme BFS} : recherche en largeur pour les trajets multi-correspondances, garantissant l'homogénéité du mode de transport et un temps de correspondance minimum de 60 minutes.
    \item \textbf{Classe utilitaire TransportHelper} : extraction de la logique de validation des correspondances dans une classe dédiée et testable unitairement (\texttt{isValidConnection()}, \texttt{isSameMode()}, \texttt{getTripDuration()}). Cette refactorisation a permis d'améliorer significativement le score de mutation (+9 points).
    \item \textbf{Données JSON} : stockage dans des fichiers JSON (\texttt{transports.json}, \texttt{hotels.json}, \texttt{activities.json}).
    \item \textbf{Gestion d'erreurs} : mécanisme de retry (3 tentatives) pour l'API de géocodage externe, exception dédiée \texttt{GeocodingException}.
\end{enumerate}

% ============================================
% SECTION 2 : MANUEL D'UTILISATION
% ============================================
\section{Manuel d'utilisation}

\subsection{Prérequis}

\begin{itemize}[noitemsep]
    \item Java 17 ou supérieur
    \item Maven 3.8+
    \item Connexion Internet (pour le géocodage)
\end{itemize}

\textbf{Note} : Toutes les commandes doivent être exécutées depuis le dossier \texttt{serveur/}.

\subsection{Commandes}

\begin{lstlisting}
# Compilation
mvn clean compile

# Tests unitaires uniquement (107 tests)
mvn clean test -DskipITs

# Tests d'integration uniquement (17 tests) - necessite d'abord mvn test
mvn failsafe:integration-test

# Tous les tests (unitaires + integration)
mvn clean verify

# Rapport de couverture JaCoCo -> target/site/jacoco/index.html
mvn clean test jacoco:report

# Rapport de mutation PIT -> target/pit-reports/*/index.html
mvn org.pitest:pitest-maven:mutationCoverage

# Execution de l'application (scenario Bordeaux -> Paris)
mvn exec:java -Dexec.mainClass="fr.univ.holitrip.HolitripMain"

# Autres scenarios de demonstration
mvn exec:java -Dexec.mainClass="fr.univ.holitrip.HolitripMain2"
\end{lstlisting}

% ============================================
% SECTION 3 : RAPPORT DE COUVERTURE
% ============================================
\section{Rapport de couverture de code}

Nous avons utilisé \textbf{JaCoCo} pour mesurer la couverture de notre suite de \textbf{107 tests unitaires} aux niveaux instruction et branche.

\subsection{Scores globaux}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Métrique} & \textbf{Score} \\
\hline
Couverture des instructions & \textbf{93\%} (1809/1936) \\
\hline
Couverture des branches & \textbf{78\%} (253/322) \\
\hline
Couverture des lignes & \textbf{91\%} (409/451) \\
\hline
Couverture des méthodes & \textbf{97\%} (58/60) \\
\hline
\end{tabular}
\caption{Scores de couverture JaCoCo (13 classes analysées)}
\end{table}

\begin{tcolorbox}[colback=green!5,colframe=green!50,title=Configuration JaCoCo]
Le \texttt{pom.xml} exclut de l'analyse les classes non métier : \texttt{HolitripMain*} (points d'entrée CLI) et les DTOs du package \texttt{model} (\texttt{Activity}, \texttt{Coordinates}, \texttt{Hotel}, \texttt{Transport}, \texttt{Trip}). Ces exclusions permettent de mesurer la couverture réelle du code métier.
\end{tcolorbox}

\subsection{Détail par classe}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|c|l|}
\hline
\textbf{Classe} & \textbf{Instr.} & \textbf{Branch.} & \textbf{Commentaire} \\
\hline
\texttt{TransportHelper} (util) & 98\% & 85\% & Utilitaires transport \\
\hline
\texttt{HaversineDistanceService} & 100\% & -- & Formule mathématique \\
\hline
\texttt{JsonTransportService} & 95\% & 83\% & Algorithme BFS bien couvert \\
\hline
\texttt{PackageBuilder} & 96\% & 73\% & Logique d'assemblage \\
\hline
\texttt{JsonActivityService} & 91\% & 57\% & Filtrage par distance \\
\hline
\texttt{JsonHotelService} & 89\% & 83\% & Filtrage par critères \\
\hline
\texttt{ApiGeocodingService} & 77\% & 64\% & Retry et erreurs testés \\
\hline
\texttt{Package} (model) & 93\% & 80\% & Méthodes métier testées \\
\hline
\texttt{GeocodingException} & 100\% & -- & Exception personnalisée \\
\hline
\end{tabular}
\caption{Détail de la couverture par classe}
\end{table}

\subsection{Justification des parties non couvertes}

\begin{itemize}
    \item \textbf{ApiGeocodingService (77\%)} : Les branches non couvertes concernent le code de gestion d'erreurs HTTP rares (timeout réseau, codes HTTP inattendus). Ces cas sont difficiles à reproduire en test unitaire sans mocking intensif du client HTTP.
    
    \item \textbf{Branches non couvertes (26\%)} : Certaines branches correspondent à du code défensif (null checks) ou des combinaisons d'erreurs exceptionnelles. Ces branches protègent contre des cas limites mais ne modifient pas le comportement observable.
    
    \item \textbf{JsonActivityService (57\% branches)} : Les branches manquantes concernent les cas où aucune activité ne correspond aux critères (catégorie inexistante, distance maximale trop restrictive).
\end{itemize}

% ============================================
% SECTION 4 : RAPPORT DE MUTATION
% ============================================
\section{Rapport d'analyse par mutation}

Nous avons utilisé \textbf{PIT} (PITest) pour évaluer la qualité de nos tests via l'analyse par mutation. PIT est configuré pour cibler les mêmes classes que JaCoCo (exclusion des \texttt{HolitripMain*} et DTOs).

\subsection{Score de mutation}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Métrique} & \textbf{Valeur} \\
\hline
Couverture des lignes (classes mutées) & 398/442 (\textbf{90\%}) \\
\hline
Mutations générées & 281 \\
\hline
Mutations tuées & 215 \\
\hline
\textbf{Score de mutation} & \textbf{77\%} \\
\hline
Mutations sans couverture & 15 \\
\hline
\textbf{Force des tests} & \textbf{81\%} \\
\hline
Tests exécutés & 1179 (4.2 tests/mutation) \\
\hline
\end{tabular}
\caption{Résumé de l'analyse PIT}
\end{table}

\begin{tcolorbox}[colback=green!5,colframe=green!50,title=Interprétation]
Le score de mutation de \textbf{77\%} indique que nos tests détectent 77\% des bugs potentiels introduits par PIT. La \textbf{force des tests} de \textbf{81\%} représente le taux de détection sur le code effectivement couvert, montrant l'excellente efficacité des assertions.
\end{tcolorbox}

\subsection{Détail par mutateur}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Mutateur} & \textbf{Générés} & \textbf{Tués} & \textbf{Taux} \\
\hline
NegateConditionalsMutator & 155 & 125 & \textbf{81\%} \\
MathMutator & 29 & 26 & \textbf{90\%} \\
BooleanTrueReturnValsMutator & 26 & 20 & \textbf{77\%} \\
ConditionalsBoundaryMutator & 18 & 7 & 39\% \\
EmptyObjectReturnValsMutator & 18 & 10 & 56\% \\
VoidMethodCallMutator & 14 & 8 & 57\% \\
NullReturnValsMutator & 9 & 8 & \textbf{89\%} \\
BooleanFalseReturnValsMutator & 7 & 7 & \textbf{100\%} \\
PrimitiveReturnsMutator & 5 & 4 & 80\% \\
\hline
\textbf{Total} & \textbf{281} & \textbf{215} & \textbf{77\%} \\
\hline
\end{tabular}
\caption{Détail des mutations par type}
\end{table}

\subsection{Justification des mutants survivants}

\begin{itemize}
    \item \textbf{NegateConditionalsMutator (30 survivants)} : Conditions défensives (null checks) et branches d'erreur. Certains sont des \textbf{mutants équivalents} où inverser la condition ne change pas le comportement (ex: liste toujours non-null).
    
    \item \textbf{ConditionalsBoundaryMutator (11 survivants)} : Changements de bornes (\texttt{<} → \texttt{<=}) non détectés car nos tests n'utilisent pas systématiquement des valeurs exactement aux limites (ex: 60 minutes exactement de correspondance).
    
    \item \textbf{EmptyObjectReturnValsMutator (8 survivants)} : Mutations sur les retours de collections vides dans des cas où le test vérifie uniquement la présence d'erreurs, pas la valeur de retour spécifique.
    
    \item \textbf{BooleanTrueReturnValsMutator (6 survivants)} : Mutations sur des méthodes booléennes dont le résultat n'est pas directement vérifié dans tous les tests (ex: méthodes de validation interne).
    
    \item \textbf{VoidMethodCallMutator (6 survivants)} : Appels de méthodes void dont les effets de bord ne sont pas toujours vérifiés (ex: logging).
    
    \item \textbf{MathMutator (3 survivants)} : Mutations dans la formule d'Haversine où les variations sont trop faibles pour être détectées par les assertions avec delta.
\end{itemize}

\subsection{Mutants équivalents}

Certains mutants produisent un comportement identique au code original :
\begin{itemize}[noitemsep]
    \item Retour de liste vide vs \texttt{Collections.emptyList()}
    \item Conditions redondantes (double validation)
    \item Opérations sur des valeurs limites (0, chaîne vide)
\end{itemize}

% ============================================
% SECTION 5 : DIFFICULTÉS
% ============================================
\section{Difficultés rencontrées et retour d'expérience}

\subsection{Difficultés techniques}

\begin{itemize}
    \item \textbf{API de géocodage externe} : L'API \texttt{geocode.maps.co} impose des limites de requêtes (rate limiting). Nous avons implémenté un mécanisme de retry avec backoff et créé un stub (\texttt{TestGeocodingService}) pour les tests d'intégration.
    
    \item \textbf{Algorithme BFS} : L'implémentation des trajets multi-correspondances avec toutes les contraintes (homogénéité du mode, temps minimum, pas de cycles) a nécessité plusieurs itérations. La logique complexe de validation des correspondances rendait difficile l'atteinte d'un bon score de mutation.
    
    \item \textbf{Amélioration du score de mutation} : Le score initial de 68\% révélait des mutants survivants dans la logique de validation des transports. La refactorisation avec création de \texttt{TransportHelper} a permis d'isoler cette logique et d'écrire des tests unitaires ciblés, augmentant le score à 77\%.
    
    \item \textbf{Couverture des branches conditionnelles} : Certaines branches (\texttt{ConditionalsBoundaryMutator} à 39\%) nécessiteraient des tests avec valeurs exactement aux limites (ex: 60 minutes de correspondance), ce qui n'était pas toujours pertinent du point de vue métier.
\end{itemize}

\subsection{Retour d'expérience}

\begin{itemize}
    \item L'injection de dépendances a grandement facilité l'écriture des tests unitaires avec mocks et le travail en parallèle sur différents services
    \item Les tests d'intégration ont permis de détecter des bugs de composition non couverts par les tests unitaires (interactions entre services réels)
    \item L'analyse par mutation a révélé des faiblesses dans nos assertions (trop permissives) et guidé la refactorisation du code pour améliorer la testabilité
    \item \textbf{Un score de couverture élevé ne garantit pas des tests de qualité} : notre couverture de 93\% cachait un score de mutation initial de seulement 68\%. L'amélioration à 77\% a nécessité à la fois des tests supplémentaires et une refactorisation du code
    \item La \textbf{convention AAA} (Arrange-Act-Assert) a amélioré la lisibilité et la maintenabilité des tests, facilitant l'identification des scénarios testés
    \item Le respect des exigences du projet (correspondances, homogénéité, critères utilisateurs) a guidé la conception des tests fonctionnels
\end{itemize}

% ============================================
% CONCLUSION
% ============================================
\section*{Conclusion}

Ce projet nous a permis de mettre en pratique les notions de test logiciel : tests unitaires avec doublures (Mockito), tests d'intégration, couverture de code (JaCoCo) et analyse par mutation (PIT).

Nous avons développé \textbf{107 tests unitaires} et \textbf{17 tests d'intégration}, atteignant une couverture de \textbf{93\%} en instructions et \textbf{78\%} en branches sur le code métier. L'analyse par mutation révèle une force de test de \textbf{81\%}, indiquant que nos assertions détectent efficacement les bugs potentiels.

La refactorisation du code avec création de la classe utilitaire \texttt{TransportHelper} a permis d'améliorer le score de mutation de 68\% à \textbf{77\%} (+9 points), démontrant l'importance d'une architecture testable et de tests ciblés.

L'architecture modulaire avec injection de dépendances s'est révélée essentielle pour permettre le test unitaire efficace et le travail parallèle de l'équipe.

\end{document}
